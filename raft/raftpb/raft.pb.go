// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: raft/raftpb/raft.proto

package raftpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// MessageType describes which type the message is. The type invokes different operations in the Raft state machine
type MessageType int32

const (
	MsgUnknown  MessageType = 0
	MsgTick     MessageType = 1
	MsgCampaign MessageType = 2
	MsgVote     MessageType = 3
	MsgVoteRes  MessageType = 4
	MsgApp      MessageType = 5
	MsgAppRes   MessageType = 6
	MsgPropose  MessageType = 7
)

var MessageType_name = map[int32]string{
	0: "MsgUnknown",
	1: "MsgTick",
	2: "MsgCampaign",
	3: "MsgVote",
	4: "MsgVoteRes",
	5: "MsgApp",
	6: "MsgAppRes",
	7: "MsgPropose",
}

var MessageType_value = map[string]int32{
	"MsgUnknown":  0,
	"MsgTick":     1,
	"MsgCampaign": 2,
	"MsgVote":     3,
	"MsgVoteRes":  4,
	"MsgApp":      5,
	"MsgAppRes":   6,
	"MsgPropose":  7,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{0}
}

// PersistentState holds the state of the raft node which has to be persisted according to Raft paper
type PersistentState struct {
	// Term is the current term of the raft node
	Term uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	// VotedFor holds the node id for which the node voted in Term
	VotedFor             uint64   `protobuf:"varint,2,opt,name=votedFor,proto3" json:"votedFor,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PersistentState) Reset()         { *m = PersistentState{} }
func (m *PersistentState) String() string { return proto.CompactTextString(m) }
func (*PersistentState) ProtoMessage()    {}
func (*PersistentState) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{0}
}
func (m *PersistentState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PersistentState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PersistentState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PersistentState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PersistentState.Merge(m, src)
}
func (m *PersistentState) XXX_Size() int {
	return m.Size()
}
func (m *PersistentState) XXX_DiscardUnknown() {
	xxx_messageInfo_PersistentState.DiscardUnknown(m)
}

var xxx_messageInfo_PersistentState proto.InternalMessageInfo

// Message is an input to the Raft state machine. It is a holder of all relevant state
// that nodes would need to communicate to each other and internally invoke processes
type Message struct {
	// Type describes which type the message is. The type invokes different operations in the Raft state machine
	Type MessageType `protobuf:"varint,1,opt,name=type,proto3,enum=raftpb.MessageType" json:"type,omitempty"`
	// From describes who is the initiator of this message
	From uint64 `protobuf:"varint,2,opt,name=from,proto3" json:"from,omitempty"`
	// To describes to whom the message should be delivered
	To                   uint64   `protobuf:"varint,3,opt,name=to,proto3" json:"to,omitempty"`
	Term                 uint64   `protobuf:"varint,4,opt,name=term,proto3" json:"term,omitempty"`
	LogIndex             uint64   `protobuf:"varint,5,opt,name=logIndex,proto3" json:"logIndex,omitempty"`
	LogTerm              uint64   `protobuf:"varint,6,opt,name=logTerm,proto3" json:"logTerm,omitempty"`
	Reject               bool     `protobuf:"varint,7,opt,name=reject,proto3" json:"reject,omitempty"`
	Entries              []Entry  `protobuf:"bytes,8,rep,name=entries,proto3" json:"entries"`
	CommitIndex          uint64   `protobuf:"varint,9,opt,name=commitIndex,proto3" json:"commitIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{1}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

type Entry struct {
	Term                 uint64   `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Index                uint64   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e9d4c87982c6a6a, []int{2}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("raftpb.MessageType", MessageType_name, MessageType_value)
	proto.RegisterType((*PersistentState)(nil), "raftpb.PersistentState")
	proto.RegisterType((*Message)(nil), "raftpb.Message")
	proto.RegisterType((*Entry)(nil), "raftpb.Entry")
}

func init() { proto.RegisterFile("raft/raftpb/raft.proto", fileDescriptor_1e9d4c87982c6a6a) }

var fileDescriptor_1e9d4c87982c6a6a = []byte{
	// 438 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x52, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xb6, 0x1d, 0xc7, 0x4e, 0xc7, 0x7f, 0x52, 0x6b, 0x7f, 0x54, 0x59, 0x3d, 0x98, 0x28, 0x97,
	0x46, 0x48, 0x75, 0xa4, 0xf2, 0x04, 0x2d, 0x2a, 0x12, 0x07, 0x4b, 0x95, 0x09, 0x1c, 0xb8, 0x39,
	0xc9, 0x66, 0x31, 0xad, 0x3d, 0xd6, 0xee, 0x14, 0xc8, 0x99, 0x13, 0x6f, 0xc0, 0x23, 0xe5, 0xd8,
	0x27, 0x40, 0x34, 0xbc, 0x08, 0xf2, 0xd8, 0xa9, 0x82, 0xc4, 0xc5, 0xfe, 0xbe, 0xf9, 0xe6, 0xdb,
	0xf9, 0x76, 0x35, 0x70, 0xa2, 0xf3, 0x35, 0xcd, 0x9a, 0x4f, 0xbd, 0xe0, 0x5f, 0x52, 0x6b, 0x24,
	0x14, 0x5e, 0x5b, 0x3a, 0x3d, 0x57, 0x05, 0x7d, 0xbc, 0x5f, 0x24, 0x4b, 0x2c, 0x67, 0x0a, 0x15,
	0xce, 0x58, 0x5e, 0xdc, 0xaf, 0x99, 0x31, 0x61, 0xd4, 0xda, 0x26, 0x97, 0x70, 0x7c, 0x23, 0xb5,
	0x29, 0x0c, 0xc9, 0x8a, 0xde, 0x52, 0x4e, 0x52, 0x08, 0x70, 0x49, 0xea, 0x32, 0xb2, 0xc7, 0xf6,
	0xd4, 0xcd, 0x18, 0x8b, 0x53, 0x18, 0x7c, 0x46, 0x92, 0xab, 0xd7, 0xa8, 0x23, 0x87, 0xeb, 0x4f,
	0x7c, 0xf2, 0xdd, 0x01, 0x3f, 0x95, 0xc6, 0xe4, 0x4a, 0x8a, 0x33, 0x70, 0x69, 0x53, 0x4b, 0xf6,
	0x8e, 0x2e, 0xfe, 0x4f, 0xda, 0x50, 0x49, 0x27, 0xcf, 0x37, 0xb5, 0xcc, 0xb8, 0xa1, 0x19, 0xb2,
	0xd6, 0x58, 0x76, 0x87, 0x31, 0x16, 0x23, 0x70, 0x08, 0xa3, 0x1e, 0x57, 0x1c, 0xc2, 0xa7, 0x20,
	0xee, 0xdf, 0x41, 0xee, 0x50, 0xbd, 0xa9, 0x56, 0xf2, 0x6b, 0xd4, 0x6f, 0x83, 0xec, 0xb9, 0x88,
	0xc0, 0xbf, 0x43, 0x35, 0x6f, 0x2c, 0x1e, 0x4b, 0x7b, 0x2a, 0x4e, 0xc0, 0xd3, 0xf2, 0x93, 0x5c,
	0x52, 0xe4, 0x8f, 0xed, 0xe9, 0x20, 0xeb, 0x98, 0x38, 0x07, 0x5f, 0x56, 0xa4, 0x0b, 0x69, 0xa2,
	0xc1, 0xb8, 0x37, 0x0d, 0x2e, 0x86, 0xfb, 0xc4, 0xd7, 0x15, 0xe9, 0xcd, 0x95, 0xbb, 0xfd, 0xf9,
	0xdc, 0xca, 0xf6, 0x3d, 0x62, 0x0c, 0xc1, 0x12, 0xcb, 0xb2, 0xa0, 0x76, 0xfe, 0x11, 0x0f, 0x39,
	0x2c, 0x4d, 0xae, 0xa1, 0xcf, 0xce, 0x7f, 0x3e, 0xe2, 0x33, 0xe8, 0x17, 0x6c, 0x6c, 0x2f, 0xdd,
	0x92, 0xa6, 0x73, 0x95, 0x53, 0xce, 0xf7, 0xfe, 0x2f, 0x63, 0xfc, 0xe2, 0x9b, 0x0d, 0xc1, 0xc1,
	0x9b, 0x89, 0x11, 0x40, 0x6a, 0xd4, 0xbb, 0xea, 0xb6, 0xc2, 0x2f, 0x55, 0x68, 0x89, 0x00, 0xfc,
	0xd4, 0xa8, 0x79, 0xb1, 0xbc, 0x0d, 0x6d, 0x71, 0x0c, 0x41, 0x6a, 0xd4, 0xab, 0xbc, 0xac, 0xf3,
	0x42, 0x55, 0xa1, 0xd3, 0xa9, 0xef, 0x91, 0x64, 0xd8, 0xeb, 0xac, 0x0d, 0xc9, 0xa4, 0x09, 0x5d,
	0x01, 0xe0, 0xa5, 0x46, 0x5d, 0xd6, 0x75, 0xd8, 0x17, 0x43, 0x38, 0x6a, 0x71, 0x23, 0x79, 0x5d,
	0xeb, 0x8d, 0xc6, 0x1a, 0x8d, 0x0c, 0xfd, 0xab, 0xb3, 0xed, 0x63, 0x6c, 0x3d, 0x3c, 0xc6, 0xd6,
	0x76, 0x17, 0xdb, 0x0f, 0xbb, 0xd8, 0xfe, 0xb5, 0x8b, 0xed, 0x1f, 0xbf, 0x63, 0xeb, 0xc3, 0x30,
	0x99, 0x1d, 0xac, 0xe1, 0xc2, 0xe3, 0x5d, 0x7a, 0xf9, 0x27, 0x00, 0x00, 0xff, 0xff, 0xfc, 0xf5,
	0xdc, 0xe1, 0x9c, 0x02, 0x00, 0x00,
}

func (m *PersistentState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PersistentState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PersistentState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VotedFor != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.VotedFor))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CommitIndex != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.CommitIndex))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Reject {
		i--
		if m.Reject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LogTerm != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.LogTerm))
		i--
		dAtA[i] = 0x30
	}
	if m.LogIndex != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.LogIndex))
		i--
		dAtA[i] = 0x28
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x20
	}
	if m.To != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x18
	}
	if m.From != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRaft(dAtA []byte, offset int, v uint64) int {
	offset -= sovRaft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PersistentState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.VotedFor != 0 {
		n += 1 + sovRaft(uint64(m.VotedFor))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRaft(uint64(m.Type))
	}
	if m.From != 0 {
		n += 1 + sovRaft(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovRaft(uint64(m.To))
	}
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.LogIndex != 0 {
		n += 1 + sovRaft(uint64(m.LogIndex))
	}
	if m.LogTerm != 0 {
		n += 1 + sovRaft(uint64(m.LogTerm))
	}
	if m.Reject {
		n += 2
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.CommitIndex != 0 {
		n += 1 + sovRaft(uint64(m.CommitIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRaft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRaft(x uint64) (n int) {
	return sovRaft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PersistentState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotedFor", wireType)
			}
			m.VotedFor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotedFor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogTerm", wireType)
			}
			m.LogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reject = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitIndex", wireType)
			}
			m.CommitIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRaft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRaft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRaft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRaft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRaft = fmt.Errorf("proto: unexpected end of group")
)
